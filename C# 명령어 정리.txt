Console.Read() = scanf("%c")
Console.ReadLine() = scanf("%s")
Console.Write = printf("\n")
Console.WriteLine = printf("")
{0}, {1}, {2} = %x, %y, %z(x, y, z는 미지수)
"a" + "b" = ab
Console.WriteLine($"v1 = {v1}, v2 = {v2}") = 중괄호 안에 있는 변수값을 출력

4bit => 8bit = 암시적 형변환(자료 손실X)
8bit => 4bit = 명시적 형변환(자료 손실O)(double 변수 x가 있을때 int로 바꾸는법 = (int)x;)

Parse(), TryParse = 문자열 <=> 숫자 변환 (문자열이 숫자가 아닐 때 = Parse = 에러, TryParse = false 반환)
try {} catch = 예외(에러) 발생 시 처리하는 문장
Convert 클래스 = string을 숫자형으로 바꾸는 여러 메소드를 제공
ToString(), ToInt32() = 숫자를 원하는 진수로 처리 ex)ToString(123, 2) = 123을 2진수로 표현한 문자열로 변경
delimiters={',', ' ', '-'}; s.Split(delimiters); = 빈칸, 콤마, -기호로 문자를 구분
문자열 연결 방법: +연산자 사용, 문자열 보간($), String.Format, String.Concat()과 String.Join()
문자열 검색: Contains() = 특정 문자열이 포함 되어 있으면 true 아니면 false를 반환, IndexOf() = 특정 문자/문자열이
나타나는 인덱스를 리턴(0부터 시작, 문자열이 없으면 -1 리턴), StringComparison = 대소문자 구분하지 않는 비교

조건연산자(조건) ? true : false;
null : 어떤 객체도 참조하지 않는 참조형 변수
Null 조건 연산자 ? : s가 null일 때는 Length를 찾지 않음(if (s?.Length > 0))
nullable형 : 값 형식 변수에 null을 할당, Nullable <T>를 사용해서 선언, T는 데이터 형, ==와 != 연산만 사용 가능, 다른 비교는 Nullable 클래스의 Compare() 메소드를 사용
이때 null 값은 모든 숫자보다 작다고 나옴
Nullable <int> => int?
Nullable <double> => double?
Nullable 타입을 non-nullable 타입에 할당 시 ?? 연산자 사용
?? : null 일 때 0을 할당
null을 숫자와 비교시 무조건 False 출력
HasValue 속성 : 변수가 값을 가지면 true, null이면 false를 리턴

열거형(서로 관련 있는 상수들의 집합의 정의) enum : 배열과 비슷함
상수(변하지 않는 값) const, readonly
const : 선언될 떄 값 할당됨, Classname.VariableName 으로 사용, 컴파일 시 값이 결정됨
readonly : 실행될 때/객체가 생성자에 의해 초기화될 때 값 할당됨, Instance.VariableName으로 사용,
런타임(컴퓨터 프로그램이 실행되고 있는동안의 동작) 시 값이 결정됨

C# 자료형 : 값 형식, 참조 형식
값 형식(변수가 실제 데이터 값을 저장하는 형식) : 기본 C# 형식(int, double, char, bool 등), enum, struct
참조 형식(변수가 값이 저장 되어 있는 곳의 위치를 저장하는 형식) : object, string, dynamic, class, interface, delegate

형식에 따른 기본값
참조형식        null
숫자 값 형식    0
bool            false
char            '\0'
enum            식 (E)0 값 E = 열거형 식별자
struct          모든 값 형식 필드를 기본값으로 설정하고 모든 참조 형식 필드를 null로 설정하여 생성한 값
nullable 형식   HasValue 속성은 false이고 Value 속성은 정의되지 않은 인스턴스(같은 클래스에 속하는 개개의 객체)

C#에서 모든 형식은 Object로 부터 상속됨 Object = object
값 형식의 변수 => object : 박싱(Boxing)(값 형식의 변수 박싱 => object로 포장 => 힙에 저장)
object => 값 형식의 변수 : 언박싱(Unboxing)(object => 값 형식을 꺼냄(형식변환을 위한 캐스팅 필요))
object는 참조형식이기 때문에 힙((여러 개의 값 중에서 가장 크거나 작은 값을 빠르게 찾기 위해 만든 이진 트리(부모 노드 밑의 자닉 노드 개수를 최대 2개로 제한하는 트리)
힙은 항상 완전 이진 트리(트리의 위부터 아래, 왼쪽부터 오른쪽의 순서로 빠짐없이 가득 차있는 이진 트리)의 형태를 띠어야 하고, 부모의 값은 항상 자식의 값보다 크거나, 작아야 함))에 데이터를 할당
int나 double과 같은 값 형식의 자료는 스택(후입선출의 특성을 가지는 자료구조)에 데이터를 할당